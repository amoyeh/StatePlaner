<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
    <script type="text/javascript" src="SimpleStateMachine.js"></script>
    <style type="text/css">
        .hrLine {
            border: none;
            border-bottom: 1px solid #EEE;
            margin: 30px 0px;
        }

        .mainWrap {
            max-width: 1110px;
            min-width: 840px;
            margin: auto;
            font-size: medium;
            font-family: 'Microsoft JhengHei', '微軟正黑體', sans-serif;
        }

        h2 {
            font-weight: normal;
            font-size: 32px;
        }

        h3 {
            font-weight: normal;
            font-size: 24px;
        }

        .subnote {
            font-size: 13px;
        }

        .codenote {
            box-sizing: border-box;
            padding: 4px 20px;
            border-bottom: 1px dashed #999;
            display: block;
            font: bold 20px 'Times New Roman';
            width: 800px;
        }

        .codeChinese {
            font-family: 'Microsoft JhengHei', '微軟正黑體', sans-serif;
            font-size: 15px;
            font-weight: normal;
            padding-left: 20px;
        }

        #lightTestDiv {
            position: relative;
            height: 190px;
        }

        #lightdiv {
            position: absolute;
            top: 0px;
            left: 100px;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: #333333;
        }

        #txtArea {
            position: absolute;
            top: 0px;
            left: 170px;
            height: 160px;
            width: 500px;
            border: 1px solid #CCC;
            border-radius: 4px;
            background: #F3F3F3;
            padding: 5px;
        }

        #startLightTestBtn {
            padding: 5px;
        }
    </style>
</head>
<body>
    <div class="mainWrap">

        <h3> Finite State Machine (有限狀態機) 介紹</h3>
        <p>
            Finite State Machine 是一種用來表達在一個設計的環境下，所有不同狀態相互溝通所使用的數學演算模型，
            在此環境下限制只能有一個狀態為使用中，很適合用於規劃及解決複雜的機制。
            例如，現實生活中常見的紅綠燈也是一種 Finite State Machine 的演繹。假設紅燈，綠燈，黃燈各是一種狀態，這三個燈不會同時發光，只可能存在於一個狀態。
            相互的關係也很清楚，紅燈只能到綠燈，綠燈只能到黃燈，黃燈只能到紅燈。
        </p>

        <h3>Finite State Machine 常用到的演繹</h3>
        <ul>
            <li>硬體與電路設計 例如：上述紅綠燈範例</li>
            <li>人工智能 例如：遊戲中敵人看到玩家攻擊，沒體力時逃跑</li>
            <li>介面設計 例如：photoshop 點選魔術棒工具後變為魔術棒狀態，所有影響到的介面會對應作不同顯示</li>
            <li>機制流程規劃 例如：販賣機的操作流程圖規劃</li>
        </ul>

        <h3>Finiate State Machine 範例</h3>

        <p>
            透過紅綠燈的演繹作為範例，流程圖示：
            <div style="margin:20px 0px;">
                <img src="StateExample.png" />
            </div>
        </p>
        <p>點選開始執行範例</p>
        <div id="lightTestDiv">
            <input type="button" id="startLightTestBtn" onclick="runLightTest();" value="開始" />
            <div id="lightdiv"></div>
            <div id="txtArea"></div>
        </div>

        <p>Typescript 原始碼，請參閱註解說明、如下 <a href="http://www.codelab.tw/blog/?p=98" target="_blank">(typescript 介紹連結)</a>  </p>

        <p>上述範例同時也使用到了 Design pattern 中的 State Pattern，<a target="_blank" href="http://en.wikipedia.org/wiki/State_pattern">更多 State Pattern 介紹</a></p>

        <h3>Finiate State Machine 的限制與演變 </h3>

        <p>
            根據 Madhukar Anand 指出，傳統的 Finiate State Machine 有以下的限制
            <a target="_blank" href="http://www.cis.upenn.edu/~lee/06cse480/lec-HSM.pdf">(下列介紹原文 http://www.cis.upenn.edu/~lee/06cse480/lec-HSM.pdf)</a>
            <ul>
                <li>如果 狀態(state) 過多過於複雜，此架構變得難以管理</li>
                <li>在實際操作中會發現許多 狀態(state) 有類似的機制，但此設計無法將類似狀態的機制整合</li>
                <li>重複使用在別的環境的彈性低</li>
            </ul>
        </p>
        <p>在1980年間 David Harel 提出了 Statecharts 的概念，補足了 State Machine 上述的缺點，最重要新增的功能為 狀態(State) 可以有巢狀結構。</p>
        <h3>巢狀、多層級有限狀態機 (Hierarchical Finiate State Machine)</h3>
        <p>
            <h4>巢狀結構的狀態示意圖：</h4>
            <div style="margin:20px 0px;">
                <img src="subState.png" />
            </div>
            <ul>
                <li>巢狀結構下每個 State 中可涵蓋其它 State ， State A 所涵蓋的 State A1 稱之為 sub state ， 對於 State A1 來說其上一層 StateA 為 super state</li>
                <li>當 State A1 被設定為開啟時， State A (super state) 開啟的邏輯會優先執行 </li>
                <li>在程式設計上，同樣邏輯可定義在 State A 中，不同有差異邏輯可定義在 State A1 與 State A2 中，達到類似物件導向中同指令不用重複撰寫的繼承</li>
                <li>繼承的設計提升了重複性使用及替換的可能性</li>
            </ul>

            <h4>State Enter 與 Exit</h4>
            State 在設計上可以在進入及離開時規劃觸發事件 ，在下範例中 State C 到 State D 的流程事件為：
            <div style="margin:20px 0px;">
                <img src="stateEnterExit.png" />
            </div>
            <ol>
                <li>State C 進入 觸發 State C enter 事件</li>
                <li>State C 到 State D 指令執行</li>
                <li>State C exit 事件觸發 </li>
                <li>State D enter 事件觸發 </li>
            </ol>

            <h4>多層巢狀結構的執行流程圖：</h4>
            <div style="margin:20px 0px;">
                <img src="stateTransition.png" />
            </div>
            依照前述，開始紅色指令執行時，State 執行流程如下
            <ol>
                <li>執行紅色箭頭指令到 State A11 </li>
                <li>State A enter 事件觸發 </li>
                <li>State A1 enter 事件觸發 </li>
                <li>State A11 enter 事件觸發，完成紅色箭頭指令 </li>
            </ol>
            在 State A11 到 State B1 的綠色箭頭指令執行流程如下
            <ol>
                <li>執行綠色箭頭指令到 State B1 </li>
                <li>State A11 exit 事件觸發 </li>
                <li>State A1 exit 事件觸發 </li>
                <li>State A exit 事件觸發 </li>
                <li>State B enter 事件觸發 </li>
                <li>State B1 enter 事件觸發，完成綠色箭頭指令 </li>
            </ol>

            <h4>State Transition 規劃</h4>
            <div style="margin:20px 0px;">
                <img src="stateTranPlan.png" />
            </div>
            規劃狀態時，可設定每個狀態能夠到達的下個狀態路線，例如上圖
            <ul>
                <li>StateQ 下可以轉移狀態到 StateR 或 StateS </li>
                <li>StateR 下可以轉移狀態到 StateT </li>
                <li>StateS 或 StateT 不能轉移到任何其它狀態</li>
            </ul>
        </p>

        <p>以上為簡要的 Finiate State Machine 介紹，在下個文章中會針筆者已開發支援所有上述功能的一套程式庫 StatePlanner.js 使用作說明</p>

    </div>

</body>
</html>